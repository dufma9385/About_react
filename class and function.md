# 리액트 컴포넌트 선언 방식 

https://devowen.com/298

## 우선 컴포넌트란?

컴포넌트는 단순한 템플릿 이상의 기능을 수행한다.

데이터가 주어졌을때 이에 맞는 UI를 만들어 주는 기능,

라이프 사이클 API를 통해 컴포넌트가 화면에 나타날 때, 사라질 때, 변할 때 작업들을 수행 할 수 있다.



## 1. 클래스형 컴포넌트

```react
class App extends Component {

  render(){

    const test = "";

    return <div>{test}</div>;

  }

}
```

- render 함수가 반드시 존재해야 한다.(그 안에서 보여줄 JSX를 반환해야한다)
- state 의 사용이 가능
- 라이프 사이클 API 사용이 가능
- 임의 메서드를 정의할 수 있다.
- 코드가 길고 복잡 (constroctor, this, binding등)
- 로직의 재사용이 어렵다
- porps를 재사용하기에 타임아웃이 지나기 전에 props가  재사용되며 예상과 다르게 동작할 수 있는 문제점 발생 (별도의 예방작업 필요)
- Stateful컴포넌트 라고도 불림
  - 로직과 상태를 컴포넌트 내에서 구현
  - 상대적으로 복잡한 UI로직

=> 사실 둘의 차이는 크지 않다

크기와 성능은 비슷, 함수형 컴포넌트에서 지원하지 않는 기능은 Hooks에서  가능해졌다.



## 2. 함수형 컴포넌트

```react
function App() {

 const test = "";

 return <div>{test}</div>

}
```

- 클래스형에 비해 선언하기 간단
- 메모리 자원을 클래스형에 비해 적게 차지
- 빌드 후 배포시 결과물의 크가가 작다.
- state관리와 라이프 사이클의 사용 불가 => 훅의 등장으로 보완
  - 코드 재사용 좋아짐
- 가돋성이 좋고 테스트가 쉽다.
- 화살표 함수의 경우 함수를 파라미터로 전달할 때 유용
  - 일반 함수는 자신이 종속된 객체를 this로 가리키며(리턴 위에), 화살표 함수는 자신이 종속된 인스턴스를 가리킴(리턴 안쪽)
- state조작시 hooks의 useState와 같은 세터함수를 반드시 사용
- Stateless컴포넌트 라고도 불림
  - state사용하지 않고 단순하게 데이터 받아서 (props) UI에 뿌려주기때문

**props**는 프로퍼티를 줄인 표현으로 컴포넌트 속성을 설정할 때 사용하는 표현이다.

**props** 값은 해당 컴포넌트를 불러와 사용하는 부모 컴포넌트에서 설정할 수 있다.

(클래스형의 경우 render에서 this.prpops를 조회해 사용 가능)

props의 경우 부모가 설정, 자식은 읽기만 할수 있는 값(변경은 부모에서)

**State**는 컴포넌트 내부에서 바뀔 수 있는 값을 의미한다







##### Hooks 

- state를 사용할 수 있는 useState 추가됨
  - 인자로 초기 state를 넣어주면 state와 state업데이트 함수가 배열형태로 반환 됨
  - 사용하는 state의 수는 제한 없어서 여러번 사용 가능
- 비교적 간단한 라이프 사이클을 위한 useEffect함수 추가
  - 컴포넌트가 마운트 되었을 때  업데이트, 마운트 해제의 경우 사용



<hr>
## 3. Hooks

class를 작성하지 않고도 state와 라이프사이클 방법과 같은 리액트의 기능사용 가능

#### Hooks의 사용 이유?

1. 컴포넌트 사이에서 상태와 관련된 로직을 재사용하기 어렵다.(ex. 스토어에 컴포넌트를 연결하는 것)

   컴포넌트로부터 상태 관련 로직을 추상화 할 수 있다.

   => 독립적인 테스트와 재사용이 가능하다.

   => Hook은 계층 변화 없이 상태관련 로직 재사용 가능

2. 복잡한 컴포넌트들은 이해하기 어렵다.

   로직을 기반을 둔 작은 함수로 컴포넌트를 나눈다( 구독 설정 및 데이터 불러오기와 같은)

클래스 형에서 setTimeOut을 지나기 전에 props를 다시 사용하게 되면 이전의 상태는 없어지고 이후에 상태만 확인할 수 있다 -> 재사용성이 떨어짐

