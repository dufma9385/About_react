# 리액트 컴포넌트 스타일링

https://blog.nerdfactory.ai/2019/10/25/react-styled-components.html

## 1. Sass

##### CSS pre-pocessor( CSS 전처리기 )

복잡한 작업을 쉽게 할 수 있게, 코드의 재활용성 높게, 코드의 가독성 높게

=> 유지보수 쉽게

#### 전처리기 특징

스타일 시트를 쪼개 관리할 수 있다. => 스타일 시트를 여러개로 쪼개더라도 최종적으로는 컴파일 된 1개의 스타일 시트만을 서버에서 불러오게 된다.

(일반 css에서 별도의 css를 호출하거나 임포트 할 수 있지만 각 호출은 새로운 http 요청을 발생시키며 성능을 저해시킬 수 있다)

색상, 글자 속성과 같은 변수를 선언하고 활용할 수 있게 한다.(반복 줄임)

셀렉터 중첩 가능(css에서 반복해 선언해야만 했던 셀렉터 들을 한번에 묶어 단순화 시킬 수 있다) => 구문 짧아지고 부모 자식의 상하구조 파악 쉽

sass : 가장 오래되고 대중적이라 참고할 자료가 많다.

​		: 내장기능도 많다

​    : compass와 병용하면 리소스 경로 직접 참조 가능 (특정 폴더 내 이미지 모두 참조, 이미지 크기 참조 가능)

less : 브라우저에 내장된 JS 인터프리터만으로 컴파일 가능-> 디펜던시 자유



Sass의 문제점

	1. 정해진 가이드가 없으면 구조가 복잡해진다.
 	2. CSS 클래스 명에 대한 고민
 	3. 스크롤 지옥
 	4. 여전히 CSS 클래스로 조건부 스타일링



## 2. CSS Module

리액트 프로젝트에서 CSS 클래스가 중첩되는 것을 완벽히 방지할 수 있다.

CSS 파일의 확장자를 .module.css 로 설정

-> css를 불러와서 사용할 때 클래스 이름을 고유한 값으로 자동생성하여 스타일 클래스 이름이 중첩되는 현상을 방지한다.

리액트 컴포넌트 파일에서 해당 CSS 피일을 불러올 때 파일에 선언한 클래스 이름들이 모두 고유해진다.

고유 CSS 클래스 이름이 만들어지는 과정에서는 파일경로, 이름, 클래스, 해쉬값등ㅇ ㅣ사용될 수 있다.

##### 사용 상황

- 레거시 프로젝트에 리액트를 도입할 때 (기존 프로젝트에 있던 CSS 클래스와 이름이 중복되어도 스타일이 꼬이지 않게 해줍니다.)
- CSS 클래스를 중복되지 않게 작성하기 위하여 CSS 클래스 네이밍 규칙을 만들기 귀찮을 때



## styled-components

자바스크립트의 태그가 지정된 템플릿 리터럴과 CSS의 시능을 사용하여 구성요소에 반응하는 스타일 제공하는 CSS in JS (JS 안에 CSS를 작성) 스타일링을 위한 프레임 워크이다.

(CSS in JS는 자바스크립트를 사용하여 구성요소의 스타일을 지정하는 기술이다,	자바스크립트에서 구문 분석되면 css가 스타일 요소로 생성되어 돔위에 직접 첨부한다)

자바스크립트 코드 내에서 이란 css로 구성 요소의 스타일을 지정할 수 있다.

버튼을 자바스크립트 변수로 명확하게 볼 수 있고 백틱에 정의된 스타일은 일반 css스타일이다.

중첩스타일 속성도 일반 css스타일과 함께 표시

### 왜 styled-components를 사용해야 할까?

- 자유로운 CSS 커스텀 컴포넌트를 만들 수 있다.

- 스타일링과 동시에 해당 스타일을 가진 컴포넌트를 만든다.

- 모바일 지원 : 리액트 네이티브에서 jsx코드를 쉽게 읽을 수 있도록 주석에 별명 지정 가능, 간단 호출하여 스타일 컴포넌츠로 변환 가능

- 스타일 컴포넌츠는 클래스에서 프루프를 사용하길 주장

```css
const Subtitle = styled.h2`
  font-size: 2em;
  color: ${props => (props.primary ? "red" : "green")};
`;
<Subtitle primary>Hello World</Subtitle>;
```

- 서버사이드 랜더링 지원
- Props를 통한 조건부 스타일링
  - styled-components를 임포트 해서 .js에서 스타일링 할 수 있다.
  - 여러 개의 CSS클래스 사용, 스타일을 적용한 것처럼 props사용하여 특정 스타일 부여 가능.
  - & 문자 사용, Sass처럼 자기 자신 선택 가능
- body를 위해 컴포넌트를 만들 필요가 없다. 전역으로 설정 가능
- 컴포넌트를 재활용하면서 추가 html 태그를 부여하고 싶을 때, 기존 컴포넌트를  확장해서 새로운 태그 생성 가능 ex)버튼을 앵커, 링크로 만들때





<hr>



CSS나 SASS같이 class, id, tag name를 가져와 쓰지 않고, 스타일 지정된 컴포넌트 생성하여 Tag 쓰듯 스타일컴포넌트를 쓰는 것을 말한다

리액트에서 ui단위를 나누어 컴포넌트화 하듯, 스타일을 컴포넌트화 하여 재사용이 가능하며 전역에서 중첩 사용되지 않게 (컴포넌트 자체에서만 적용됨) 만들어준다.

스타일자체를 컴포넌트로 만들어 사용한단다! props로 속성까지 전달하여 조건을 붙일수도 있다.

App.js

```react
import React from 'react';
import styled from 'styled-components';

const Circle = styled.div`
  width: 5rem;
  height: 5rem;
  background: ${props => props.color || 'black'};
  border-radius: 50%;
`;

function App() {
  return <Circle color="blue" />;
}

//Circle 컴포넌트에서 color props 값을 설정해줬으면 해당 값을 배경색으로 설정 그렇지 않으면 검정색으로 설정


export default App;
```



백틱 ㅅ용하여  스타일 구문

props사용으로 삼항연산자나 && || 사용 가능 




<hr></hr>

#### 가장 일반적인 방법 **두 가지를 이용하여 순수 css에서 state변화에 따른 조건부 스타일링을 할때의 문제점!!

#### **(인라인 형식, css클래스 명을 활용한 조건부 스타일링)

1. state값에 따라 스타일을 바인딩 해야 하는 경우
2. props가 많아지고 그에 따른 조건부 스타일링도 많아질 때
3. 거의 같은 형태의 스타일링을 가지고 있으나 일부분만 변경하여 새로운 컴포넌트를 만들어야 할 때
4. 같은 스타일을 가지고 있는 다른 선택자의 경우
5. 색상 값과 반복되는 키워드가 존재할 때

==> CSS 클래스가 많아 질 수도 있고 인라인 스타일링 길이가 길어질 수도 있다!!

### 이때 등장한 **Sass**

CSS의 언어적 특성과 위의 불편함을 해결하기 위해 중첩, 변수, 믹스인, 확장 및 로직을 스타일 시트에 구현한 전처리 엔진 형태의 CSS 전처리기

#### Sass의 효율적인 CSS 구조 설계

순수 css에서 태그 혹은 임포트를 사용해서 css파일을 구조화 하게되면 css파일의 호출이 매번 새로운 http 요청을 발생시키고 성능저하의 원인이 될 수 있다

그러나 Sass의 임포트는 개발환경에서 많은 css파일이 복잡하더라도 하나의 스타일 시트로 컴파일이 된다 -> http요청에 의한 성능이슈 해결

==> css의 구조화가 가능해 짐에 따라 스타일 시트를 한눈에 파악하기 쉬워짐, 스타일 시트 구조를 논리적으로 파악할 수 있게 도와준다.

스타일 시트를 쪼개서 관리할 수 있다.

#### Sass의 문제

1. 정해진 가이드가 없으면 구조가 복잡해진다.
2. css클래스 명에 대한 고민
3. 스크롤 지옥
4. 여전히 css 클래스로 조건부 스타일링을 하고 있다.

#### 위 문제들을 해결하려 등장한 Styleld-Component

Tagged 템플릿 리터럴을 이용해 스타일 정보를 실제 CSS 코드를 사용하여 자바스크립트 파일 안에 스타일을 선언하는 CSS in JS방식 중 하나이다

컴포넌트와 스타일 간의 매핑을 제거하고 Sass나 Less와 같은 전처리기가 제공하는 프로그래밍적 동작 방식도 제공한다.

